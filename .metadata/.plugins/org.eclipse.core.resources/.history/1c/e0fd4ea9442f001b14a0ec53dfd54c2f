package tierPSO;

import java.util.ArrayList;

public class App {
	private final static int MAX_TIERS = 1;
	private final static int NUM_OF_PARTICLES = 50;
	private final static int MAX_PARTICLES_PER_TIRE = (int) Math.floor(NUM_OF_PARTICLES/ 5);
	private final static int DIMENSIONS = 3;
	private final static int ITERATIONS = 50;
	private final static double TIER_INERTIA = 0.5;
	private final static double GlOBAL_INERTIA = 0.1;
	
	
	private static double[][] bounds;

	private static ArrayList<double[]> particleLocations = new ArrayList<double[]>();
	private static ArrayList<double[]> particlePBs = new ArrayList<double[]>(); // personal best for each particle

	private static ArrayList<Double> velocitiesOfLocations = new ArrayList<Double>();

	private static ArrayList<ArrayList<Integer>> tiers = new ArrayList<ArrayList<Integer>>(); 
	// contains indexs of particles in tier.
	public static void main(String[] args) {
		bounds = new double[][] {{0,1},{0,1},{0,1}};
		ArrayList<Integer> tierZero = new ArrayList<Integer>();
		
	    for(int i = 0; i < NUM_OF_PARTICLES; i++){
	        particleLocations.add(randomLocation());
	        tierZero.add(i);
	    }
	    tiers.add(tierZero);

	    for(int i = 0; i < ITERATIONS; i++){
	        double[] gbest = new double[DIMENSIONS];
	        double gbestCost = 0;
	        ArrayList<double[]> localAverages = new ArrayList<double[]>();

	        for(int j = 0; j < NUM_OF_PARTICLES; j++){
	        	particle = etc
	            if(inTier(particle) == 0){
	                if(gbestCost == 0){
	                    gbest = particle;
	                    gbestCost = locationCost(particle);
	                } else {
	                    if(gbestCost < locationCost(particle)){
	                    gbest = particle;
	                    gbestCost = locationCost(particle);
	                    }
	                }
	            }
	        }

	        int k = 0;
	        for(ArrayList<Integer> tier: tiers){
	            double[] tierAverage = new double[DIMENSIONS];
	            for(int particleIndex:tier){
	                particle = particleLocations.get(particleIndex);
	                tierAverage = add(tierAverage, particle);
	                
	            }
	            tierAverage = divide(tierAverage, NUM_OF_PARTICLES);
	            localAverages.add(tierAverage);
	            k++;
	        }

	        for(int j =0; j < NUM_OF_PARTICLES; j++){
	            updateLocation(j,gbest);
	        }
	    }
	}
	
	private static boolean inBounds(double[] particle) {
		int i = 0;
		for(double value: particle) {
			if(value < bounds[i][0] || value > bounds[i][1]) {
				return false;
			}
			i++;
		}
		return true;
	}
	private static double[] add(double[] input1, double[] input2){
	    double[] a1 = input1.clone();
	    double[] a2 = input2.clone();
	    double[] output = new double[a1.length];
	    for(int i =0; i< a1.length; i++){
	        output[i] = a1[i] + a2[i]; 
	    }
	    return output;
	}
	private static double[] divide(double[] input1, double input2){
	    double[] a1 = input1.clone();
	    double[] output = new double[a1.length];
	    for(int i =0; i< a1.length; i++){
	        output[i] = a1[i]/input2; 
	    }
	    return output;
	}

	private static double locationCost(){
	    return cost;
	    // dependant on problem
	}

	private static double[] randomLocation(){
	    return location;
	    // location is not in a tier.
	}

	private static double inTier(int particleIndex){
		int i = 0;
	    for(ArrayList<Integer> tier: tiers){
	        if(tier.contains(particleIndex)){
	            return i;
	        }
	        i++;
	    }
	    return 0;
	}

	private static double updateLocation(int particleIndex, double[] gbest){
	    double t = inTier(particleIndex);
	    if(t == 0){

	    } else {

	    }
	}

	private static void updateTier(){
	    // adds new tiers and removes tiers based on critera
	}

	private static void addTierLevel(){

	}
	private static void lowerTire(){

	}
}
