package tierPSO;

import java.util.ArrayList;
import java.util.Random;

public class App {
	private final static int MAX_TIERS = 1;
	private final static int NUM_OF_PARTICLES = 50;
	private final static int MAX_PARTICLES_PER_TIER = (int) Math.floor(NUM_OF_PARTICLES/ 5);
	private final static int DIMENSIONS = 3;
	private final static int ITERATIONS = 50;
	private final static int DISTANCE_BETWEEN_PARTICLES_FOR_TIER= 1;
	private final static double TIER_INERTIA = 0.5;
	private final static double GlOBAL_INERTIA = 0.1;
	
	
	
	
	private static ArrayList<Tier> tiers = new ArrayList<Tier>(); 
	// contains indexs of particles in tier.
	
	
	/**
	 * need to change it so that location is done by double[] instead of by index!!!!
	 * bounds needs to constrain
	 * in Tier for location needs to be written
	 * update tier
	 * add tier
	 * and lower tier needs to be written
	 * 
	 * 
	 * need to work out where whole tier moves as one or seperate tiers within
	 * 
	 * need to work out what defines a tier, how close or how many particles.
	 * 
	 * tier needs to be a class as needs to have a parent/ child
	 * @param args
	 */
	public static void main(String[] args) {
		pso( new double[] {0.6,0.6,0.6}, 0.1, 0.1, new double[][] {{0,1},{0,1},{0,1}});
	}
	
	
	private static double[] add(double[] input1, double[] input2){
	    double[] a1 = input1.clone();
	    double[] a2 = input2.clone();
	    double[] output = new double[a1.length];
	    for(int i =0; i< a1.length; i++){
	        output[i] = a1[i] + a2[i]; 
	    }
	    return output;
	}
	private static double[] divide(double[] input1, double input2){
	    double[] a1 = input1.clone();
	    double[] output = new double[a1.length];
	    for(int i =0; i< a1.length; i++){
	        output[i] = a1[i]/input2; 
	    }
	    return output;
	}

	
	private static void pso(double[] inertia, double cognitiveCo, double socialCo, double[][] bounds) {
		Tier tierZero = new Tier(0);
		AntennaArray aa = new AntennaArray(3, 90);
		tierZero.add(new Particle(aa, randomVelocity(), randomLocation(), inertia, cognitiveCo, socialCo, bounds));
	    for(int i = 0; i < NUM_OF_PARTICLES - 1; i++){
	        tierZero.addParticle(new Particle(randomLocation(), randomVelocity()));
	    }
	    tiers.add(tierZero);

	    for(int i = 0; i < ITERATIONS; i++){
	        double[] gbest = new double[DIMENSIONS];
	        double gbestCost = 0;
	        ArrayList<double[]> localAverages = new ArrayList<double[]>();
	        int index = 0;
	        for(Particle particle: particles){
	        	
	            if(particle.getTier().getLevel() == 0){
	                if(gbestCost == 0){
	                    gbest = particle.getBestPosition();
	                    gbestCost = Particle.getCost(gbest);
	                } else {
	                    if(gbestCost < Particle.getCost(particle.getBestPosition())){
	                    gbest = particle.getBestPosition();
	                    gbestCost = Particle.getCost(gbest);
	                    }
	                }
	            }
	            index++;
	        }

	        for(Tier tier: tiers){
	            double[] tierAverage = new double[DIMENSIONS];
	            for(int particleIndex:tier){
	                Particle particle = particles.get(particleIndex);
	                tierAverage = add(tierAverage, particle.getBestPosition());
	                
	            }
	            tierAverage = divide(tierAverage, NUM_OF_PARTICLES);
	            localAverages.add(tierAverage);
	        }

	        for(Particle particle: particles){ // needs to be changed for particles in tier;
	        	if(particle.getTier().getLevel() > 0) {
	        		particle.update(localAverage.get());
	        	} else {
	        		particle.update(gbest);	        	
	        	}
	        }
	    }
	}
		
	
	
	private static double[] randomLocation(){
		Random random = new Random();
		double [] location = {};
		while(inTier(location) > 0) {
			location = random;
		}
	    return location;
	    // location is not in a tier.
	}

	private static double[] randomVelocity() {
		Random random = new Random();
		double[] v = new double[DIMENSIONS];
		for(int i =0; i < DIMENSIONS; i ++) {
			v[i] = random.nextDouble();
		}
		return v;
	}

	
	private static double inTier(double[] location){
		int i = 0;
	    for(ArrayList<Integer> tier: tiers){
	        if(tier.contains(location)){ // check needed !!!
	        	// if location is close enough to needed number of particles
	            return i;
	        }
	        i++;
	    }
	    return 0;
	}
}

	private static void updateTier(){
	    // adds new tiers and removes tiers based on critera
		
		// how to get over problem of minimum particle number being too small to create new tier
		if(particle 1 and 2 and 3 all close enough goes into tier)
		if(already tier add new particles)
			if(particles equals max create new tier)
		if(particle distances is too small get rid of particle from tier but only if tier lower tier dissolves/ has enough room for particles)
		if(tier doesnt contain enough particles dissolve tier)
		if(lower tier dissolves lower level of higher tiers)
	}

	private static void addTierLevel(){
		add tier to tiers and put particles in
	}
	private static void lowerTire(){
		remove particles from tier and move particles to lower tier
		
	}
}
